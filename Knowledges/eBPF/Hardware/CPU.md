# CPU
![image](https://github.com/user-attachments/assets/b62e93db-8274-456d-87b1-c462727fcf73)

## Источники событий
![image](https://github.com/user-attachments/assets/a438faca-2506-45e8-97c3-2a966c4c46be)
А также попадания в кеш (PMC) - можно связать с вызовом приложения.<br>
А также трассировка стека, нахождение что привело к событию
## Оверхед
При трассировке событий планировщика эффективность обретает особую важность,
так как некоторые события планировщика, например переключение контекста, могут происходить миллионы раз в секунду. В некоторых случаях трассировка планировщика увеличивает нагруз-
ку на систему более чем на 10%.

Трассировка планировщика с помощью BPF применяется для краткосрочного
и специализированного анализа, при этом нужно понимать, что она сопряжена
с оверхедом.

Инструментация редких событий, например запуска процессов и миграции потоков (происходящих не чаще
чем тысячу раз в секунду), порождает незначительный оверхед. Профилирование
(выборка по времени) тоже позволяет ограничить оверхед уменьшением частоты
выборки до незначительных пропорций.
## Стратегия
1. Прежде чем тратить время на инструменты анализа, убедитесь, что рабочая
нагрузка на CPU запущена. Проверьте загрузку CPU системы (например,
с помощью mpstat(1)) и убедитесь, что все CPU включены (иногда по какой-то
причине некоторые могут быть отключены).

2. Убедитесь, что рабочая нагрузка имеет вычислительный характер

 - a) определите наибольшую загрузку CPU в системе или на одном процессоре
(например, с помощью mpstat(1));

- b) определите наибольшую задержку в очереди на выполнение (например,
с помощью runqlat(1) из BCC). Программные ограничения, например,
в контейнерах, могут искусственно ограничивать доступ процессов к CPU,
поэтому производительность вычислительного приложения может быть
низкой, даже когда система практически простаивает. Этот нелогичный
сценарий можно опознать, изучив задержку в очереди на выполнение.

## PMC
В облачной среде счётчики PMC часто отключают
```
# dmesg | grep PMU
[ 2.827349] Performance Events: unsupported p6 CPU model 85 no PMU driver,
software events only.
```
### tlbstat
```
# tlbstat -C0 1
K_CYCLES K_INSTR IPC DTLB_WALKS ITLB_WALKS K_DTLBCYC K_ITLBCYC DTLB% ITLB%
2875793 276051   0.10 89709496  65862302   787913    650834    27.40 22.63
2860557 273767   0.10 88829158  65213248   780301    644292    27.28 22.52
2885138 276533   0.10 89683045  65813992   787391    650494    27.29 22.55
2532843 243104   0.10 79055465  58023221   693910    573168    27.40 22.63
[...]
```
 - K_CYCLES: тысячи тактов CPU;
 - K_INSTR: тысячи инструкций CPU;
 - IPC: инструкций на такт;
 - DTLB_WALKS: число обходов TLB данных;
 - ITLB_WALKS: число обходов TLB инструкций;
 - K_DTLBCYC: тысячи тактов, когда хотя бы один обработчик отсутствия страницы (Page-Miss Handler, PMH) был активен во время обхода TLB данных;
 - K_ITLBCYC: тысячи тактов, когда хотя бы один обработчик PMH был активен во время обхода TLB инструкций;
 - DTLB%: доля активных тактов TLB данных в общем числе тактов;
 - ITLB%: доля активных тактов TLB инструкций в общем числе тактов.

"Data TLB walk" refers to the hardware-assisted process of translating a virtual address to a physical address using the Translation Lookaside Buffer (TLB) , specifically when handling a data access (as opposed to instruction fetch).

## BPF tools
![image](https://github.com/user-attachments/assets/bbfc8c8d-0eaf-42e4-aaf8-617ebb3182ba)

## Очередь на выполнение
На 36 ядерной системе запущено 72 потока, при этом 0 idle, в очереди на выполнение 72 процесса (включая выполняющиеся)
```
# runqlat 10 1
Tracing run queue latency... Hit Ctrl-C to end.
usecs : count distribution
0 -> 1 : 1906 |*** |
2 -> 3 : 22087 |****************************************|
4 -> 7 : 21245 |************************************** |
8 -> 15 : 7333 |************* |
16 -> 31 : 4902 |******** |
32 -> 63 : 6002 |********** |
64 -> 127 : 7370 |************* |
128 -> 255 : 13001 |*********************** |
256 -> 511 : 4823 |******** |
512 -> 1023 : 1519 |** |
1024 -> 2047 : 3682 |****** |
2048 -> 4095 : 3170 |***** |
4096 -> 8191 : 5759 |********** |
8192 -> 16383 : 14549 |************************** |
16384 -> 32767 : 5589 |********** |
32768 -> 65535 : 372 | |
65536 -> 131071 : 10 |

# sar -uq 1
Linux 4.18.0-virtual (...) 01/21/2019 _x86_64_ (36 CPU)
11:06:25 PM CPU %user %nice %system %iowait %steal %idle
11:06:26 PM all 88.06 0.00  11.94   0.00    0.00   0.00
11:06:25 PM runq-sz plist-sz ldavg-1 ldavg-5 ldavg-15 blocked
11:06:26 PM 72      1030     65.90   41.52   34.75    0
[...]
```
## Измерение задержки очереди на выполнение
sched_wakeup_new - то же что и sched_wakeup, но вызывается при появлении нового потока, который будет выполняться первый раз <br>
sched_wakeup - вызывается для переключения состояния потока из состояний TASK_UNINTERRUPTABLE и TASK_INTERAPTABLE в состояние TASK_RUNNING - задача готова к выполнянию <br>
sched_switch - выполняется два раза, для прерывания предыдущей задачи и добавления ожидающей в состоянии TASK_RUNNING. <br>
Тут нужно понимать, если выполение потока прерывается из за исчерпания квоты, статус TASK_RUNNING остаётся, вызов sched_wakeup по идее и не нужен т.к. задача сразу попадает в очередь на выполнение (принудительное переключение контекста), поэтому в коде есть if конструкция.

Поскольку здесь используется макрос TASK_RUNNING, к программе подключается
файл заголовка linux/sched.h (#include), содержащий его определение.

```
#!/usr/local/bin/bpftrace
#include <linux/sched.h>

tracepoint:sched:sched_wakeup,
tracepoint:sched:sched_wakeup_new
{
@qtime[args->pid] = nsecs;
}
tracepoint:sched:sched_switch
{
if (args->prev_state == TASK_RUNNING) {
@qtime[args->prev_pid] = nsecs;
}
$ns = @qtime[args->next_pid];
if ($ns) {
@usecs = hist((nsecs - $ns) / 1000);
}
delete(@qtime[args->next_pid]);
}
END
{
clear(@qtime);
}
```
## Длина очереди на выполнение
runqlen выбирает данные по времени,с частотой 99 Гц, тогда как runqlat трассирует события планировщика.
```
# runqlen 10 1
Sampling run queue length... Hit Ctrl-C to end.
runqlen : count distribution
0 : 47284 |****************************************|
1 : 211 | |
2 : 28 | |
3 : 6 | |
4 : 4 | |
5 : 1 | |
6 : 1 | |
```
