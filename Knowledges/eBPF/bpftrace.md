# bpftrace
![image](https://github.com/user-attachments/assets/8bfb83f4-92ca-44c8-b2e1-0bd01e82cdde)

## Сравнение bpftrace с другими инструментами
мониторинга
- perf(1): в сравнении с компактным и высокоуровневым языком bpftrace язык
сценариев perf(1) выглядит слишком многословным. perf(1) поддерживает
эффективный способ передачи событий в двоичном формате через perf record
и режимы формирования сводной информации в памяти — perf top. bpftrace
реализует эффективные методы обобщения информации в ядре, например по-
строение гистограмм, тогда как встроенные в ядро сводки perf(1) ограничены
счетчиками (perf stat). Возможности perf(1) расширяются с помощью программ
BPF, но пишутся на другом языке, не таком высокоуровневом, как bpftrace. При-
мер программы BPF для perf(1) ищите в приложении D.
 - Ftrace: bpftrace предлагает высокоуровневый язык программирования, похожий
на C и awk, тогда как средства инструментации в Ftrace, включая триггеры hist,
имеют свой, ни на что не похожий синтаксис. Ftrace имеет меньше зависимостей,
поэтому он лучше подходит для использования в небольших встраиваемых си-
стемах Linux. Также Ftrace поддерживает такие режимы инструментации, как
подсчет вызовов функций, которые действуют более оптимально, чем источни-
ки событий в bpftrace. (Моя версия funccount(8) на основе Ftrace запускается
и останавливается быстрее и имеет меньший оверхед, чем эквивалентная версия
на основе bpftrace.)
- SystemTap: оба трассировщика, bpftrace и SystemTap, предлагают высокоуровне-
вые языки программирования. Но bpftrace основан на технологиях, встроенных
в ядро Linux, а SystemTap добавляет свои модули ядра, которые оказались не-
надежными в системах, отличных от RHEL. Но в SystemTap уже идут работы
по реализации поддержки BPF по аналогии с bpftrace, что должно повысить
надежность трассировщика в этих других системах. Сейчас у SystemTap больше
вспомогательных функций в своих библиотеках для инструментации различных
событий.
 - LTTng: LTTng оптимизирует вывод дампов событий и предоставляет инструмен-
ты для их анализа. Он использует иной подход к анализу производительности,
чем bpftrace, ориентированный на выполнение анализа в масштабе реального
времени.
 - Прикладные инструменты: область применения прикладных инструментов
и инструментов среды выполнения ограничены пространством пользователя.
bpftrace, напротив, способен также инструментировать и обрабатывать события
в пространстве ядра, позволяя идентифицировать источники проблем, недоступ-
ные прикладным инструментам. Однако прикладные инструменты имеют свои
преимущества — обычно они адаптированы для использования с конкретным
приложением или средой выполнения. Профилировщик базы данных MySQL
уже знает, как инструментировать запросы, а профилировщик JVM — сборку
мусора. В bpftrace все это приходится реализовывать вручную.

## Примеры однострочных комманд
```
Подсчитывает число страниц, загруженных каждым процессом:
bpftrace -e 'software:major-faults:1 { @[comm] = count(); }'

Подсчитывает число отказов страниц для каждого процесса:
bpftrace -e 'software:faults:1 { @[comm] = count(); }'

Профилирует стек в пространстве пользователя для PID 189 с частотой 49 Гц:
bpftrace -e 'profile:hz:49 /pid == 189/ { @[ustack] = count(); }'

# bpftrace -l 'kprobe:vfs_*'
kprobe:vfs_fallocate
kprobe:vfs_truncate
kprobe:vfs_open
kprobe:vfs_setpos
kprobe:vfs_llseek
[...]
bpftrace -l 'kprobe:vfs_*' | wc -l
56
```

## Программирование на bpftrace
```
#!/usr/local/bin/bpftrace
// эта программа измеряет продолжительность выполнения vfs_read()
kprobe:vfs_read
{
@start[tid] = nsecs;
}
kretprobe:vfs_read
/@start[tid]/
{
$duration_us = (nsecs - @start[tid]) / 1000;
@us = hist($duration_us);
delete(@start[tid]);
}
```
Комментарии
```
// это комментарий

/*
* это многострочный
* комментарий
*/
```
Порядок использования
```
bpftrace -e program

bpftrace file.bt
```
Структура
```
probes { actions }

probes /filter/ { actions }

probe1,probe2,... { actions }

Есть два специальных типа зондов, для которых не нужно указывать дополни -
тельные идентификаторы BEGIN и END. Они срабатывают в начале и в конце
программы bpftrace (в точности как в awk(1))
```
Фильтры
```
/pid == 123/

/pid != 0/ то же самое что /pid/

/pid > 100 && pid < 1000/
```
Действия
```
{ action one; action two; action three }

{ $x = 42; printf("$x is %d", $x); }
```
Hello world
```
# bpftrace -e 'BEGIN { printf("Hello, World!\n"); }'
Attaching 1 probe...
Hello, World!
^C

#!/usr/local/bin/bpftrace
BEGIN
{
printf("Hello, World!\n");
}
```
### Формат определения зондов

Иерархия зависит от типа зонда. Например:
```
kprobe:vfs_read
uprobe:/bin/bash:readline
```
