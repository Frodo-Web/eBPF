# bpftrace
![image](https://github.com/user-attachments/assets/8bfb83f4-92ca-44c8-b2e1-0bd01e82cdde)

## Сравнение bpftrace с другими инструментами
мониторинга
- perf(1): в сравнении с компактным и высокоуровневым языком bpftrace язык
сценариев perf(1) выглядит слишком многословным. perf(1) поддерживает
эффективный способ передачи событий в двоичном формате через perf record
и режимы формирования сводной информации в памяти — perf top. bpftrace
реализует эффективные методы обобщения информации в ядре, например по-
строение гистограмм, тогда как встроенные в ядро сводки perf(1) ограничены
счетчиками (perf stat). Возможности perf(1) расширяются с помощью программ
BPF, но пишутся на другом языке, не таком высокоуровневом, как bpftrace. При-
мер программы BPF для perf(1) ищите в приложении D.
 - Ftrace: bpftrace предлагает высокоуровневый язык программирования, похожий
на C и awk, тогда как средства инструментации в Ftrace, включая триггеры hist,
имеют свой, ни на что не похожий синтаксис. Ftrace имеет меньше зависимостей,
поэтому он лучше подходит для использования в небольших встраиваемых си-
стемах Linux. Также Ftrace поддерживает такие режимы инструментации, как
подсчет вызовов функций, которые действуют более оптимально, чем источни-
ки событий в bpftrace. (Моя версия funccount(8) на основе Ftrace запускается
и останавливается быстрее и имеет меньший оверхед, чем эквивалентная версия
на основе bpftrace.)
- SystemTap: оба трассировщика, bpftrace и SystemTap, предлагают высокоуровне-
вые языки программирования. Но bpftrace основан на технологиях, встроенных
в ядро Linux, а SystemTap добавляет свои модули ядра, которые оказались не-
надежными в системах, отличных от RHEL. Но в SystemTap уже идут работы
по реализации поддержки BPF по аналогии с bpftrace, что должно повысить
надежность трассировщика в этих других системах. Сейчас у SystemTap больше
вспомогательных функций в своих библиотеках для инструментации различных
событий.
 - LTTng: LTTng оптимизирует вывод дампов событий и предоставляет инструмен-
ты для их анализа. Он использует иной подход к анализу производительности,
чем bpftrace, ориентированный на выполнение анализа в масштабе реального
времени.
 - Прикладные инструменты: область применения прикладных инструментов
и инструментов среды выполнения ограничены пространством пользователя.
bpftrace, напротив, способен также инструментировать и обрабатывать события
в пространстве ядра, позволяя идентифицировать источники проблем, недоступ-
ные прикладным инструментам. Однако прикладные инструменты имеют свои
преимущества — обычно они адаптированы для использования с конкретным
приложением или средой выполнения. Профилировщик базы данных MySQL
уже знает, как инструментировать запросы, а профилировщик JVM — сборку
мусора. В bpftrace все это приходится реализовывать вручную.

## Примеры однострочных комманд
```
Подсчитывает число страниц, загруженных каждым процессом:
bpftrace -e 'software:major-faults:1 { @[comm] = count(); }'

Подсчитывает число отказов страниц для каждого процесса:
bpftrace -e 'software:faults:1 { @[comm] = count(); }'

Профилирует стек в пространстве пользователя для PID 189 с частотой 49 Гц:
bpftrace -e 'profile:hz:49 /pid == 189/ { @[ustack] = count(); }'

# bpftrace -l 'kprobe:vfs_*'
kprobe:vfs_fallocate
kprobe:vfs_truncate
kprobe:vfs_open
kprobe:vfs_setpos
kprobe:vfs_llseek
[...]
bpftrace -l 'kprobe:vfs_*' | wc -l
56
```

## Программирование на bpftrace
```
#!/usr/local/bin/bpftrace
// эта программа измеряет продолжительность выполнения vfs_read()
kprobe:vfs_read
{
@start[tid] = nsecs;
}
kretprobe:vfs_read
/@start[tid]/
{
$duration_us = (nsecs - @start[tid]) / 1000;
@us = hist($duration_us);
delete(@start[tid]);
}
```
### Комментарии
```
// это комментарий

/*
* это многострочный
* комментарий
*/
```
### Порядок использования
```
bpftrace -e program

bpftrace file.bt
```
### Структура
```
probes { actions }

probes /filter/ { actions }

probe1,probe2,... { actions }

Есть два специальных типа зондов, для которых не нужно указывать дополни -
тельные идентификаторы BEGIN и END. Они срабатывают в начале и в конце
программы bpftrace (в точности как в awk(1))
```
### Фильтры
```
/pid == 123/

/pid != 0/ то же самое что /pid/

/pid > 100 && pid < 1000/
```
### Действия
```
{ action one; action two; action three }

{ $x = 42; printf("$x is %d", $x); }
```
### Hello world
```
# bpftrace -e 'BEGIN { printf("Hello, World!\n"); }'
Attaching 1 probe...
Hello, World!
^C

#!/usr/local/bin/bpftrace
BEGIN
{
printf("Hello, World!\n");
}
```
### Функции

Кроме printf() — функции форматированного вывода — есть еще встроенные
функции, в том числе:
 - exit(): производит выход из программы bpftrace;
 - str(char *): возвращает строку по указателю;
 - system(format[, arguments ...]): выполняет команду в командной оболочке.
```
printf("got: %llx %s\n", $x, str($x)); exit();
```
выведет значение переменной $x в шестнадцатеричном формате, а затем попытается
интерпретировать его как указатель на массив символов, завершающийся пустым
символом NULL (char *), выведет его как строку и завершит выполнение программы.

### Переменные
- Встроенные переменные (built-in variables) предопределены и предоставляются
bpftrace. Обычно они доступны только для чтения. К ним относятся pid (иденти-
фикатор процесса), comm (имя процесса), nsecs (отметка времени в наносекундах)
и curtask (адрес task_struct текущего потока).
- Временные переменные (scratch variables) можно использовать для временного
хранения результатов вычислений. Их имена начинаются с префикса «$». Сама пере-
менная и ее тип определяются первой операцией присваивания.
```
$x = 1;
$y = "hello";
$z = (struct task_struct *)curtask;
```

- Переменные-карты (map variables) хранятся в хранилище карт BPF, и их имена
должны начинаться с префикса «@». В этих переменных можно сохранять данные
для их передачи между действиями. Программа

probe1 { @a = 1; }
probe2 { $x = @a; }

присвоит число 1 переменной @a, когда возникнет событие probe1, а затем, когда
возникнет событие probe2, присвоит значение @a переменной $x. Если сначала
возникнет событие probe1, а затем probe2, переменная $x получит значение 1, в про-
тивном случае — значение 0 (значение по умолчанию для неинициализированой
переменной).

После имени переменной-карты можно указать ключ и использовать такие пере-
менные на манер хеш-таблицы (ассоциативного массива). Инструкция

@start[tid] = nsecs;

часто используется в практике: в данном случае она сохранит значение встроенной
переменной nsecs в карте с именем @start и с ключом tid (идентификатором теку-
щего потока).

@path[pid, $fd] = str(arg0);

Это пример карты с множественными ключами, здесь роль ключей играют значение
встроенной переменной pid и значение временной переменной $fd.
### Формат определения зондов

Иерархия зависит от типа зонда. Например:
```
kprobe:vfs_read
uprobe:/bin/bash:readline
```
