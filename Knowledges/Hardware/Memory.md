# Memory
Linux — это система, основанная на виртуальной памяти, где каждый процесс имеет
свое виртуальное адресное пространство. Она выполняет отображение в физиче-
ские адреса по мере необходимости. Ее дизайн допускает избыточную подписку на
физическую память, которой Linux управляет с помощью демона выгрузки страниц
и физических устройств подкачки, а также имеет компонент ядра Out-Of-Memory
Killer, который останавливает процессы при критической нехватке памяти. Linux
использует свободную память в качестве кэша файловой системы.
![image](https://github.com/user-attachments/assets/c7c30183-5590-4191-a703-c8cfad3a545f)
Процессы, управляющие памятью с по-мощью библиотеки libc, получают память из динамического сегмента виртуального
адресного пространства процесса, который называется кучей (heap). Библиотека
libc предоставляет функции для управления распределением памяти, включая
malloc() и free(). Когда процесс освобождает блок памяти, libc запоминает его
местоположение и использует эту информацию в последующих вызовах malloc().
libc увеличивает размер кучи только после исчерпания доступной памяти. Уменьшать размер кучи обычно не требуется, потому что это виртуальная, а не реальная
физическая память.

За отображение виртуальных адресов в физические отвечает ядро и процессор. Для
эффективности отображение адресов осуществляется группами, или страницами,
где размер каждой страницы зависит от аппаратной архитектуры процессора. 

Ядро может обслуживать запросы на получение страниц физической
памяти из своих собственных списков свободной памяти, которые поддерживает
для каждой группы микросхем ОЗУ (DRAM) и CPU. 
Само ядро тоже потребляет
память из этих списков, обычно используя свой механизм управления памятью —
распределитель блоков (slab allocator).

В числе других библиотек управления памятью в пространстве пользователя можно
назвать tcmalloc и jemalloc. Среды времени выполнения, например JVM, тоже часто
предоставляют свой механизм управления памятью со средствами сборки мусора.
Другие механизмы управления могут также отображать частные сегменты для
распределения памяти вне кучи.

## Страницы памяти и подкачка
1. Приложение запрашивает блок памяти (например, вызывает функцию malloc()
из библиотеки libc).
2. Библиотека может сразу же выделить память из своего списка свободных
страниц или сначала обратиться к системе для увеличения объема доступной
ей виртуальной памяти. В зависимости от ситуации, библиотека:
 - a) увеличит размер кучи обращением к системному вызову brk() и использует
дополнительную полученную память для удовлетворения запроса;
 - b) создаст новый сегмент обращением к системному вызову mmap().
3. Спустя какое-то время приложение может попытаться использовать выделен-
ный диапазон памяти с помощью инструкций записи и чтения, вовлекающих
в работу блок управления памятью (Memory Management Unit, MMU) для пре-
образования виртуальных адресов в физические. И тогда вскрывается ложная
природа виртуальной памяти: виртуальным адресам не соответствует никакая
физическая память! Это приводит к ошибке MMU — сбою страницы (page fault).
4. Сбой страницы обрабатывается ядром, которое устанавливает соответствие
между виртуальными адресами и адресами из своих списков свободных блоков
физической памяти и затем информирует MMU об этом соответствии для ис-
пользования в будущем. Затем процесс использует дополнительную страницу
физической памяти. Такой объем физической памяти называется размером
резидентного набора (Resident Set Size, RSS).
5. С увеличением спроса на память в работу включается демон подкачки (kswapd).
Он отыскивает страницы физической памяти, которые можно освободить или
вытеснить на устройство подкачки. Освободить можно страницы трех типов
(на рис. 7.2 приведен только третий тип (с), так как рисунок иллюстрирует
жизненный цикл страниц памяти в пространстве пользователя):
 - a) страницы файловой системы, которые были прочитаны с диска и не изме-
нялись (их называют «зарезервированными на диске»): их можно удалить
немедленно и при необходимости просто прочитать повторно. Эти страницы
могут хранить выполняемый код приложений, данные и метаданные фай-
ловой системы;
 - b) страницы файловой системы, которые были изменены: это так называемые
«грязные» страницы, которые следует записать на диск перед освобожде-
нием;
 - c) страницы памяти приложения: их называют анонимной памятью, потому
что у них нет источника в файловой системе. Если в системе есть устрой-
ство подкачки, эти страницы можно освободить, предварительно сохранив
на устройстве подкачки. Операция записи страниц на устройство подкачки
называется подкачкой (в Linux).

Запросы на выделение памяти обычно следуют друг за другом очень часто: вы-
деление памяти в пространстве пользователя может происходить миллионы раз
в секунду. Операции чтения и записи, а также поиск соответствий в MMU проис-
ходят еще чаще — до нескольких миллиардов раз в секунду. Другие операции — вызовы brk() и mmap(), сбои страниц и вытеснение страниц — выполняются относительно редко.

## Демон подкачки
Демон подкачки (kswapd) периодически ищет наиболее давно использовавшиеся
(Least Recently Used, LRU) активные и неактивные страницы для освобождения.
Он активируется, когда объем свободной памяти достигает нижнего предела, а за-
тем переходит в фоновый режим, когда этот объем пересекает верхний предел.
![image](https://github.com/user-attachments/assets/b049e6d7-399f-49a7-9c87-ea2c77aa3f68)
В фоновом режиме kswapd действует с минимальным приоритетом. За исключе-
нием конкуренции за процессор и выполнение операций дискового ввода/вывода,
он не должен напрямую влиять на производительность приложений. Если kswapd
не может освободить память достаточно быстро и объем доступной памяти до-
стигает нижнего порога, то демон переходит в активный режим работы, стремясь
освободить память для удовлетворения запросов на ее распределение. В этом ре-
жиме выделения памяти блокируются (зависают) и синхронно ждут освобождения
страниц

Прямое восстановление памяти может приводить к вызову функций модуля ядра
shrinker: они освобождают память, которая могла храниться в кэшах, включая
кэши ядра.

## Устройства подкачки
Устройства подкачки обеспечивают ухудшенный режим работы системы в условиях нехватки памяти: процессы могут продолжать выделять память, но при этом
реже используемые страницы начинают перемещаться между физической памятью и устройствами подкачки туда и обратно, что приводит к сильному замедлению при-
ложений. Некоторые производственные системы работают без устройств подкачки,
так как ухудшенный режим работы для них неприемлем. Для таких критически
важных систем проще и дешевле запустить множество избыточных (и исправных!)
серверов, чем использовать устройство подкачки. (Это характерно, например, для
облачных экземпляров Netflix.) Если системе без устройства подкачки не хватает
памяти, механизм ядра OOM Killer жертвует процессом. Чтобы избежать этого,
обычно приложения настраиваются так, чтобы никогда не превышать пределы
доступной памяти системы.

## OOM Killer
Механизм Linux OOM Killer — последнее средство освобождения памяти: он ищет
процессы-жертвы, используя специальную эвристику, и жертвует ими, принуди-
тельно их завершая. Эвристика ищет самую большую и не самую важную жертву,
которая освободит много страниц, такую как потоки ядра или процесс init (PID 1).
Linux предоставляет возможность настройки поведения OOM Killer в масштабе
всей системы и для каждого процесса в отдельности.

## Сжатие страниц
Со временем растет фрагментация пространства свободных страниц, что затрудняет
выделение большого непрерывного фрагмента, если это потребуется. Для предот-
вращения таких затруднений ядро использует процедуру сжатия (compaction),
которая перемещает страницы для освобождения смежных областей.

## Кеширование и буферизация в файловой системе
Linux активно заимствует свободную память для кэширования файловой системы
и возвращает ее, когда возникает потребность в свободной памяти. Следствием
такого заимствования является то, что объем свободной памяти, сообщаемый си-
стемой, стремится к нулю после загрузки Linux.

Ядро Linux можно настроить так, чтобы оно предпочитало освобождать память,
занятую кэшем файловой системы, или освобождало память путем вытеснения
(vm.swappiness).
